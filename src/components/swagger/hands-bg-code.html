<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Canvas Hands</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #e8f6ee; /* Fallback background */
            font-family: sans-serif;
        }
        canvas {
            display: block; /* Removes default inline spacing */
        }

        /* UI Control Panel Styling */
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid #ddd;
            z-index: 100;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        /* Collapsed State */
        .controls.collapsed {
            max-height: 50px; /* Only show header */
            overflow: hidden;
            padding-bottom: 0;
        }
        
        /* Header Container for Title and Toggle */
        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            border-bottom: 2px solid #eb655b;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }

        .controls h3 {
            margin: 0;
            font-size: 1.1rem;
            color: #333;
        }

        /* Minimize Button */
        .toggle-btn {
            background: none;
            border: none;
            font-size: 1.2rem;
            line-height: 1;
            cursor: pointer;
            color: #555;
            padding: 0 5px;
        }
        .toggle-btn:hover {
            color: #eb655b;
        }

        .control-content {
            /* Wrapper for content to hide when collapsed */
            opacity: 1;
            transition: opacity 0.2s ease;
        }
        .controls.collapsed .control-content {
            opacity: 0;
            pointer-events: none;
        }

        .control-group {
            margin-bottom: 20px;
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
        }
        .control-group:last-child {
            border-bottom: none;
        }

        .input-row {
            margin-bottom: 8px;
        }

        label {
            display: block;
            font-size: 0.75rem;
            font-weight: 700;
            margin-bottom: 2px;
            color: #555;
            text-transform: uppercase;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
            height: 6px;
        }

        input[type="number"] {
            width: 60px;
            padding: 2px;
            font-size: 0.8rem;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        /* File Input Styling */
        input[type="file"] {
            font-size: 0.8rem;
            width: 100%;
            margin-bottom: 5px;
        }
        
        .status-msg {
            font-size: 0.7rem;
            margin-bottom: 5px;
            font-style: italic;
        }
        .status-msg.success { color: green; }
        .status-msg.error { color: red; }

        .flex-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }
        
        .note {
            font-size: 0.7rem;
            color: #eb655b;
            margin-top: 2px;
            font-style: italic;
        }
        
        .h-divider {
            margin-top: 20px;
            margin-bottom: 5px;
            font-weight: 800;
            color: #333;
            font-size: 0.9rem;
            border-bottom: 2px solid #ddd;
        }
    </style>
</head>
<body>

<!-- Canvas Element -->
<canvas id="canvas"></canvas>

<!-- UI Controls -->
<div class="controls" id="controlsPanel">
    <div class="header-row">
        <h3>Controls</h3>
        <button class="toggle-btn" id="toggleUI" title="Minimize">–</button>
    </div>

    <div class="control-content">
        
        <!-- GLOBAL MOVEMENT -->
        <div class="control-group">
            <label style="color:#eb655b;">Global Movement</label>
            <div class="input-row">
                <label>Path Angle (°)</label>
                <div class="flex-row">
                    <input type="range" id="pathAngleSlider" min="-180" max="180" value="-135">
                    <input type="number" id="pathAngleNum" value="-135">
                </div>
            </div>
             <div class="input-row">
                <label>Spread Distance</label>
                <div class="flex-row">
                    <input type="range" id="spreadSlider" min="0.5" max="2.0" step="0.1" value="1.0">
                    <input type="number" id="spreadNum" value="1.0" step="0.1">
                </div>
            </div>
            <div class="input-row">
                <label>
                    <input type="checkbox" id="showPath"> Show Movement Path
                </label>
            </div>
        </div>

        <!-- LEFT HAND -->
        <div class="control-group">
            <label style="color:#eb655b;">Left Hand</label>
            <div class="input-row">
                <label>Upload SVG File</label>
                <input type="file" id="leftFileInput" accept=".svg">
                <div id="leftStatus" class="status-msg">No file chosen</div>
            </div>
            
            <div class="input-row">
                <label>Scale</label>
                <div class="flex-row">
                    <input type="range" id="leftScaleSlider" min="0.1" max="5" step="0.1" value="1">
                    <input type="number" id="leftScaleNum" value="1" step="0.1">
                </div>
            </div>
            <div class="input-row">
                <label>Offset X</label>
                <div class="flex-row">
                    <input type="range" id="leftOffXSlider" min="-2000" max="2000" step="10" value="0">
                    <input type="number" id="leftOffXNum" value="0">
                </div>
            </div>
            <div class="input-row">
                <label>Offset Y</label>
                <div class="flex-row">
                    <input type="range" id="leftOffYSlider" min="-2000" max="2000" step="10" value="0">
                    <input type="number" id="leftOffYNum" value="0">
                </div>
            </div>
            <div class="input-row">
                <label>Rotation (°)</label>
                <div class="flex-row">
                    <input type="range" id="leftRotSlider" min="-180" max="180" value="135">
                    <input type="number" id="leftRotNum" value="135">
                </div>
            </div>
        </div>

        <!-- RIGHT HAND -->
        <div class="control-group">
            <label style="color:#eb655b;">Right Hand</label>
            <div class="input-row">
                <label>Upload SVG File</label>
                <input type="file" id="rightFileInput" accept=".svg">
                <div id="rightStatus" class="status-msg">No file chosen</div>
            </div>

            <div class="input-row">
                <label>Scale</label>
                <div class="flex-row">
                    <input type="range" id="rightScaleSlider" min="0.1" max="5" step="0.1" value="1">
                    <input type="number" id="rightScaleNum" value="1" step="0.1">
                </div>
            </div>
            <div class="input-row">
                <label>Offset X</label>
                <div class="flex-row">
                    <input type="range" id="rightOffXSlider" min="-2000" max="2000" step="10" value="0">
                    <input type="number" id="rightOffXNum" value="0">
                </div>
            </div>
            <div class="input-row">
                <label>Offset Y</label>
                <div class="flex-row">
                    <input type="range" id="rightOffYSlider" min="-2000" max="2000" step="10" value="0">
                    <input type="number" id="rightOffYNum" value="0">
                </div>
            </div>
            <div class="input-row">
                <label>Rotation (°)</label>
                <div class="flex-row">
                    <input type="range" id="rightRotSlider" min="-180" max="180" value="-45">
                    <input type="number" id="rightRotNum" value="-45">
                </div>
            </div>
        </div>
        
        <div class="control-group">
            <label>
                <input type="checkbox" id="forceCircles"> Show Helper Circles
            </label>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // --- Configuration & State ---
    const bgColor = "#e8f6ee";
    const handColor = "#eb655b";
    const pathColor = "#99ccbb"; // Color for imaginary line
    const handRadius = 50; 

    const settings = {
        global: {
            pathAngle: -135, // Default to Top-Left roughly
            spreadFactor: 1.0
        },
        left: {
            rotation: 135,
            scale: 1,
            offX: 0,
            offY: 0,
            path2D: null
        },
        right: {
            rotation: -45,
            scale: 1,
            offX: 0,
            offY: 0,
            path2D: null
        },
        showCircles: true,
        showPath: false
    };

    let width, height, centerX, centerY, maxDist;
    let mouseY = 0;

    // --- Helper: Measure SVG Bounding Box ---
    function calculateAutoOffset(dAttribute) {
        const ns = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(ns, "svg");
        svg.style.position = "absolute";
        svg.style.visibility = "hidden";
        svg.style.pointerEvents = "none";
        svg.setAttribute("width", "0");
        svg.setAttribute("height", "0");
        
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", dAttribute);
        
        svg.appendChild(path);
        document.body.appendChild(svg);
        
        let bbox;
        try {
            bbox = path.getBBox();
        } catch(e) {
            console.warn("Could not calculate BBox", e);
            bbox = { x: 0, y: 0, width: 0, height: 0 };
        }
        
        document.body.removeChild(svg);
        
        const centerX = bbox.x + (bbox.width / 2);
        const centerY = bbox.y + (bbox.height / 2);
        
        return {
            x: -centerX,
            y: -centerY
        };
    }


    // --- UI Logic ---
    function setupUI() {
        // Global
        bindInput('pathAngleSlider', 'pathAngleNum', (val) => settings.global.pathAngle = val);
        bindInput('spreadSlider', 'spreadNum', (val) => settings.global.spreadFactor = val);

        // Hands
        setupHandControls('left');
        setupHandControls('right');
        
        // Toggles
        const cbCircles = document.getElementById('forceCircles');
        cbCircles.checked = settings.showCircles;
        cbCircles.addEventListener('change', (e) => {
            settings.showCircles = e.target.checked;
        });

        const cbPath = document.getElementById('showPath');
        cbPath.checked = settings.showPath;
        cbPath.addEventListener('change', (e) => {
            settings.showPath = e.target.checked;
        });

        // Minimize Button
        const toggleBtn = document.getElementById('toggleUI');
        const panel = document.getElementById('controlsPanel');
        let isCollapsed = false;

        toggleBtn.addEventListener('click', () => {
            isCollapsed = !isCollapsed;
            if (isCollapsed) {
                panel.classList.add('collapsed');
                toggleBtn.textContent = '+';
            } else {
                panel.classList.remove('collapsed');
                toggleBtn.textContent = '–';
            }
        });
    }

    function setupHandControls(side) {
        bindInput(`${side}RotSlider`, `${side}RotNum`, (val) => settings[side].rotation = val);
        bindInput(`${side}ScaleSlider`, `${side}ScaleNum`, (val) => settings[side].scale = val);
        bindInput(`${side}OffXSlider`, `${side}OffXNum`, (val) => settings[side].offX = val);
        bindInput(`${side}OffYSlider`, `${side}OffYNum`, (val) => settings[side].offY = val);
        
        const fileInput = document.getElementById(`${side}FileInput`);
        const statusEl = document.getElementById(`${side}Status`);
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (evt) => {
                const text = evt.target.result;
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(text, "image/svg+xml");
                    const pathEl = doc.querySelector('path');
                    
                    if (pathEl) {
                        const d = pathEl.getAttribute('d');
                        if(d) {
                            settings[side].path2D = new Path2D(d);
                            
                            const autoOffset = calculateAutoOffset(d);
                            settings[side].offX = autoOffset.x;
                            settings[side].offY = autoOffset.y;
                            
                            document.getElementById(`${side}OffXSlider`).value = autoOffset.x;
                            document.getElementById(`${side}OffXNum`).value = autoOffset.x.toFixed(1);
                            document.getElementById(`${side}OffYSlider`).value = autoOffset.y;
                            document.getElementById(`${side}OffYNum`).value = autoOffset.y.toFixed(1);

                            statusEl.textContent = "Loaded & Auto-Centered!";
                            statusEl.className = "status-msg success";
                        } else {
                            throw new Error("Path found but no 'd' attribute.");
                        }
                    } else {
                        throw new Error("No <path> element found in SVG.");
                    }
                } catch (err) {
                    console.error(err);
                    statusEl.textContent = "Error parsing SVG.";
                    statusEl.className = "status-msg error";
                    settings[side].path2D = null;
                }
            };
            reader.readAsText(file);
        });
    }

    function bindInput(sliderId, numId, callback) {
        const slider = document.getElementById(sliderId);
        const num = document.getElementById(numId);

        slider.addEventListener('input', () => {
            num.value = slider.value;
            callback(parseFloat(slider.value));
        });

        num.addEventListener('input', () => {
            slider.value = num.value;
            callback(parseFloat(num.value));
        });
    }

    // --- Canvas Logic ---

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        centerX = width / 2;
        centerY = height / 2;
        
        // Calculate max radius of screen for movement reference
        maxDist = Math.hypot(width/2, height/2);

        if (mouseY === 0) mouseY = centerY; 
    }

    function draw() {
        // 1. Clear
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, width, height);

        // 2. Logic: Factor Calculation
        const distY = Math.abs(mouseY - centerY);
        let factor = distY / centerY;
        factor = Math.min(factor, 1);

        // 3. Logic: Position Calculation (Vector Math)
        
        // Convert Angle to Radians
        const angleRad = settings.global.pathAngle * Math.PI / 180;
        
        // How far out are we?
        const currentDistance = maxDist * settings.global.spreadFactor * factor;
        
        // Calculate vector offsets based on angle
        // Hand 1 uses the Angle directly
        const h1_offsetX = Math.cos(angleRad) * currentDistance;
        const h1_offsetY = Math.sin(angleRad) * currentDistance;
        
        // Hand 2 is opposite (Angle + 180)
        // Cos(a+180) = -Cos(a), Sin(a+180) = -Sin(a)
        const h2_offsetX = -h1_offsetX;
        const h2_offsetY = -h1_offsetY;

        // Apply to center
        // Note: We ADD offset because the angle determines direction relative to center
        const h1_x = centerX + h1_offsetX;
        const h1_y = centerY + h1_offsetY;

        const h2_x = centerX + h2_offsetX;
        const h2_y = centerY + h2_offsetY;


        // 4. Draw Paths (if enabled)
        if (settings.showPath) {
            ctx.save();
            ctx.strokeStyle = pathColor;
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 10]); // Dashed line
            
            // Draw Line for Hand 1 Path
            const startX1 = centerX + (Math.cos(angleRad) * maxDist * settings.global.spreadFactor);
            const startY1 = centerY + (Math.sin(angleRad) * maxDist * settings.global.spreadFactor);

            ctx.beginPath();
            ctx.moveTo(startX1, startY1);
            ctx.lineTo(centerX, centerY);
            ctx.stroke();

            // Draw Line for Hand 2 Path
            const startX2 = centerX - (Math.cos(angleRad) * maxDist * settings.global.spreadFactor);
            const startY2 = centerY - (Math.sin(angleRad) * maxDist * settings.global.spreadFactor);

            ctx.beginPath();
            ctx.moveTo(startX2, startY2);
            ctx.lineTo(centerX, centerY);
            ctx.stroke();
            
            ctx.restore();
        }

        // 5. Draw Hands
        drawHand(h1_x, h1_y, settings.left);
        drawHand(h2_x, h2_y, settings.right);

        requestAnimationFrame(draw);
    }

    function drawHand(x, y, config) {
        ctx.save();
        
        ctx.translate(x, y);
        ctx.rotate(config.rotation * Math.PI / 180);

        ctx.fillStyle = handColor;

        // Draw Helper Circle
        if (!config.path2D || settings.showCircles) {
            ctx.beginPath();
            ctx.arc(0, 0, handRadius, 0, Math.PI * 2);
            ctx.fillStyle = config.path2D ? "rgba(235, 101, 91, 0.3)" : handColor;
            ctx.fill();
            ctx.fillStyle = handColor; // Reset
        }

        // Draw SVG Path
        if (config.path2D) {
            ctx.save();
            ctx.scale(config.scale, config.scale);
            ctx.translate(config.offX, config.offY);
            ctx.fill(config.path2D);
            ctx.restore();
        }

        ctx.restore();
    }

    // --- Initialization ---
    window.addEventListener('resize', resize);
    window.addEventListener('mousemove', (e) => mouseY = e.clientY);
    window.addEventListener('touchmove', (e) => mouseY = e.touches[0].clientY);

    setupUI();
    resize();
    draw();

</script>
</body>
</html>